<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><link href="css/synchron.css" rel="stylesheet"/><title>Synchron 2020: Abstracts</title><meta name="description" content="Abstracts of talks at Synchron 2020"/><link href="apple-touch-icon.png" type="image/png" rel="apple-touch-icon" sizes="180x180"/><link href="favicon-32x32.png" type="image/png" rel="icon" sizes="32x32"/><link href="favicon-16x16.png" type="image/png" rel="icon" sizes="16x16"/><link href="site.webmanifest" rel="manifest"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png"/><meta name="theme-color" content="#ffffff"/></head><body><div class="synchron-all"><div class="navbar navbar-expand-md navbar-light synchron-navbar" id="synchron-navbar"><a class="navbar-brand" href="index.html">Synchron 2020</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsingNavbar"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="collapsingNavbar"><ul class="navbar-nav mr-auto"><li class="nav-item"><a class="nav-link" href="participation.html">Participation</a></li><li class="nav-item"><a class="nav-link" href="program.html">Program</a></li><li class="nav-item active"><a class="nav-link" href="abstracts.html">Abstracts</a></li><li class="nav-item"><a class="nav-link" href="hubs.html">Hubs</a></li><li class="nav-item"><a class="nav-link" href="history.html">History</a></li></ul></div></div><div class="synchron-content"><h1 class="d-none d-print-block">Synchron 2020</h1><div class="synchron-single-border"></div><div class="synchron-single-content"><div class="talk-details"><h2 id="Update-on-the-adoption-of-synchronous-languages-at-gh.st">Update on the adoption of synchronous languages at gh.st</h2><div class="when">26 November 2020, 09:00–09:30</div><div class="authors"><span class="speaker"><a href="https://gh.st">Kai Engelhardt</a></span></div><div class="affiliations">(gh.st)</div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="Formal-Modelling-and-Verification-of-Rate-Adaptive-Pacemakers-for-Heart-Failure">Formal Modelling and Verification of Rate Adaptive Pacemakers for Heart Failure</h2><div class="when">26 November 2020, 09:30–10:00</div><div class="authors"><span class="speaker">Moon Soo Kim</span>, <span>Weiwei Ai</span>, <span>Partha S. Roop</span>, <span>Nathan Allen</span>, <span>Rohit Ramchandra</span>, and <span>Julian Paton</span></div><div class="affiliations">(U. Auckland)</div><div class="abstract-text"><p>Cardiovascular Implantable Electronic Devices (CIEDs) are routinely implanted to treat various types of arrhythmia. However, conventional pacing algorithms may not be able to provide optimal treatment for the patients with Heart Failure (HF) and evidence suggests negative outcomes. In this paper, we introduce a formal pacemaker model that can restore heart-lung synchronization, which may bring therapeutic benefits to the patient with chronic HF. We use valued Synchronous Discrete Timed Automata (SDTA) to describe the timing requirements of the device, which is then translated into Promela for formal verification through a set of rules which are defined to maintain the synchronous semantics. The safety-critical properties are then verified using the model checker SPIN. We show that the SDTA model can be verified more efficiently than conventional approaches with pure Timed Automata (TA). Animal test results show that the pacing rates are synchronized with the respiratory cycles. In particular, the functional safety is ensured under various respiratory conditions. This work yields, for the first time, a formal model of pacing device to reinstate heart rate variability for (HF) patients.</p>
</div></div><div class="talk-details"><h2 id="A-study-of-predictable-execution-models-implementation-for-industrial-data-flow-applications-on-a-multi-core-platform-with-shared-banked-memory">A study of predictable execution models implementation for industrial data-flow applications on a multi-core platform with shared banked memory</h2><div class="when">26 November 2020, 10:30–11:00</div><div class="authors"><span class="speaker"><a href="http://www-verimag.imag.fr/~schuhm">Matheus Schuh</a></span>, <span><a href="http://www-verimag.imag.fr/~maiza/">Claire Maiza</a></span>, <span>Joël Goossens</span>, <span><a href="http://www-verimag.imag.fr/~raymond/">Pascal Raymond</a></span>, and <span><a href="https://sites.google.com/site/benoitdinechin/">Benoît Dupont de Dinechin</a></span></div><div class="affiliations">(Univ. Grenoble Alpes, Univ. Libre de Bruxelles, and Kalray SAS)</div><div class="material d-print-none"><a href="https://difusion.ulb.ac.be/vufind/Record/ULB-DIPOT:oai:dipot.ulb.ac.be:2013/313474/Holdings">(material)</a></div><div class="abstract-text"><p>We study the implementation of data-flow applications on a multi-core processor with on-chip shared multi-banked memory. Specifically, we consider the Kalray MPPA2 processor and three applications coded using the industrial toolchain SCADE Suite. We focus on the runtime environment assuming global static scheduling, time-triggered and non-preemptive execution of tasks. Our contributions include (i) a technique to implement SCADE applications compliant with execution models inspired by PREMs (PRedictable Execution Models), (ii) an exhaustive comparison of three execution models with and without isolation, and finally (iii) guidelines for predictable implementation of a data-flow application on multi-core processors with shared on-chip memory.</p>
</div></div><div class="talk-details"><h2 id="Improving-the-Scalability-of-Multimode-DAE-Structural-Analysis-by-using-Reduced-Block-Triangular-Forms">Improving the Scalability of Multimode DAE Structural Analysis by using Reduced Block Triangular Forms</h2><div class="when">26 November 2020, 11:15–11:45</div><div class="authors"><span class="speaker"><a href="https://gitlab.com/JoanThibault/home/-/wikis/">Joan Thibault</a></span>, <span><a href="http://www.irisa.fr/prive/Benoit.Caillaud/Benoit_Caillauds_Professional_homepage/Welcome.html">Benoit Caillaud</a></span>, and <span><a href="https://fr.linkedin.com/in/mathias-malandain-21179617a">Mathias Mallandain</a></span></div><div class="affiliations">(Inria Rennes)</div><div class="abstract-text"><p>The generation of efficient simulation code from a Differential Algebraic Equations (DAE)-based model relies on the structural analysis of the model, with efficient algorithms such as <a href="https://link.springer.com/article/10.1023%2FA%3A1021998624799">Pryce's Σ-method</a>.</p>
<p>However, when dealing with hybrid models with multiple modes and mode-dependent dynamics, these methods are not adapted to the resulting multimode DAE (mDAE) systems. In particular, the number of modes is roughly exponential in the size of the model, making the structural analysis of every mode untractable.</p>
<p><a href="https://dl.acm.org/doi/10.1145/3365365.3382201">Caillaud et al.</a> proposed and <a href="https://allgo18.inria.fr/apps/isamdae">implemented</a> an extension of the Σ-method for mDAE systems, relying on an implicit representation of the varying structure of the mDAE thanks to Binary Decision Diagrams (BDD), in particular the Reduced Ordered variant (ROBDD) introduced by <a href="https://dl.acm.org/doi/10.1109/TC.1986.1676819">Bryant</a>.</p>
<p>Although this algorithm is considerably more efficient than the enumeration of modes on some <a href="https://dl.acm.org/doi/10.1145/3365365.3382201">examples</a>, its performances are still hindered by the sheer size of the functions that are represented and manipulated, and by the fact that all ROBDD manipulations have an exponential worst-case complexity in both time and space.</p>
<p>However, typical engineering systems are structured and sparse: they are build from interconnected components, where each component is only connected to a small number of other components. The focus of this talk is on how this sparsity can be exploited in order to improve the scalability of the above-mentioned structural analysis algorithm.</p>
<p>Designed by Joan Thibault and implemented in the generic symbolic dynamic programming framework <a href="https://gitlab.com/boreal-ldd/snowflake">Snowflake</a>, Reduced Block Triangular Forms (RBTF) are an intermediary representation of Boolean functions that is particularly fit for such sparse structured systems. A two-step RBTF algorithm (also implemented in Snowflake) efficiently turns systems of equations into this representation while preserving the original structure.</p>
<p>To do so, the RBTF algorithm over-approximates the relations between components as a tree (called decomposition tree in the graph literature), each node of this tree being a set of components of the initial systems. Then, starting from leaves, each sub-system is solved and the solutions are projected as new constraints on their parent nodes; this process is iterated until all sub-systems are solved. This step, allowing to condensate all constraints and check their satisfiability, is called the Forward Reduction Process (FRP).</p>
<p>Constraints can then be propagated back into the initial sub-systems by performing those same projections in the reverse direction. In other words, each sub-system updates its set of solutions given the information from its parents, then send the information to its children sub-systems. This step is the Backward Propagation Process (BPP).</p>
<p>The main drawback of this approach is to find a good enough tree organisation of the components, even if the component-based organisation of the original model is not available. To overcome these limitations, we rely on a naive, but efficient enough, greedy heuristic which computes a suitable decomposition-tree for RBTF to use.</p>
</div></div><div class="talk-details"><h2 id="Implementing-true-separate-compilation---the-Blech-module-system">Implementing true separate compilation - the Blech module system</h2><div class="when">26 November 2020, 11:45–12:15</div><div class="authors"><span class="speaker">Friedrich Gretz</span> and <span>Franz-Josef Grosch</span></div><div class="affiliations">(Bosch)</div><div class="material d-print-none"><a href="https://www.blech-lang.org">(material)</a></div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="Normalizing-Lustre-in-Coq">Normalizing Lustre in Coq</h2><div class="when">26 November 2020, 14:45–15:15</div><div class="authors"><span><a href="https://www.tbrk.org">Timothy Bourke</a></span>, <span class="speaker">Paul Jeanmaire</span>, <span class="speaker"><a href="https://vertmo.github.io">Basile Pesin</a></span>, and <span><a href="https://www.di.ens.fr/~pouzet/">Marc Pouzet</a></span></div><div class="affiliations">(Inria Paris and ENS)</div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="Reactive-Probabilistic-Programming-Semantics-with-Mixed-Nondeterministic/Probabilistic-Automata">Reactive Probabilistic Programming Semantics with Mixed Nondeterministic/Probabilistic Automata</h2><div class="when">26 November 2020, 15:15–15:45</div><div class="authors"><span class="speaker"><a href="http://people.rennes.inria.fr/Albert.Benveniste/">Albert Benveniste</a></span> and <span>Jean-Baptiste Raclet</span></div><div class="affiliations">(Inria Rennes)</div><div class="abstract-text"><p>Graphical models in probability and statistics are a core concept in the growing area of probabilistic reasoning and probabilistic programming—graphical models include Bayesian networks and factor graphs. In cooperation with Jean-Baptiste Raclet (IRIT-CNRS, Toulouse), we developed a new model of Mixed (nondeterministic/probabilistic) Automata that subsumes both nondeterministic automata and graphical probabilistic models. Mixed automata are equipped with parallel composition, simulation relation, and support message passing algorithms inherited from graphical probabilistic models. We also show how Segala and Lynch Probabilistic Automata can be mapped to Mixed Automata by preserving simulation relations. However, our parallel composition differs from that of Probabilistic Automata (PA); in contrast to PA, our notion of parallel composition suits Probabilistic Programming.</p>
</div></div><div class="talk-details"><h2 id="Smoothly-translating-synchronous-languages-to-imperative-code-with-the-Semsil-intermediate-language">Smoothly translating synchronous languages to imperative code with the Semsil intermediate language</h2><div class="when">26 November 2020, 16:00–16:30</div><div class="authors"><span>Jean-Louis Colaço</span>, <span class="speaker">Baptiste Pauget</span>, and <span><a href="https://www.di.ens.fr/~pouzet/">Marc Pouzet</a></span></div><div class="affiliations">(ANSYS, ENS, and Inria)</div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="Interfacing-a-synchronous-language-with-Python-and-Jupyter-Notebooks">Interfacing a synchronous language with Python and Jupyter Notebooks</h2><div class="when">26 November 2020, 16:30–17:00</div><div class="authors"><span class="speaker"><a href="https://guillaume.baudart.eu">Guillaume Baudart</a></span>, <span><a href="https://www.irif.fr/~guatto/">Adrien Guatto</a></span>, and <span class="speaker"><a href="https://www.lri.fr/~mandel/">Louis Mandel</a></span></div><div class="affiliations">(IBM Research, Inria Paris, and IRIF - Université de Paris)</div><div class="material d-print-none"><a href="https://gitlab.inria.fr/gbaudart/2020-synchron">(material)</a></div><div class="abstract-text"><p>See also:</p>
<ul><li><a href="baudart/2020-synchron-part-1-audio.html">part1</a></li></ul><ul><li><a href="baudart/2020-synchron-part-2-rppl.html">part2</a></li></ul><ul><li><a href="baudart/2020-synchron-part-3-heptagon.html">part3</a></li></ul></div></div><div class="talk-details"><h2 id="The-Sparse-Synchronous-Model:-Yet-Another-Synchronous-Language">The Sparse Synchronous Model: Yet Another Synchronous Language</h2><div class="when">26 November 2020, 17:15–17:45</div><div class="authors"><span class="speaker"><a href="http://www.cs.columbia.edu/~sedwards/">Stephen Edwards</a></span></div><div class="affiliations">(Columbia University)</div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="The-LIsinopril-medical-prescription-in-HipHop">The LIsinopril medical prescription in HipHop</h2><div class="when">27 November 2020, 09:00–09:30</div><div class="authors"><span class="speaker"><a href="http://www.college-de-france.fr/site/gerard-berry/index.htm">Gérard Berry</a></span> and <span><a href="https://www-sop.inria.fr/members/Manuel.Serrano/">Manuel Serrano</a></span></div><div class="affiliations">(Collège de France and Inria Sophia-Antipolis)</div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="Exploring-Compositional-Neural-Networks-for-Real-time-Applications">Exploring Compositional Neural Networks for Real-time Applications</h2><div class="when">27 November 2020, 09:30–10:00</div><div class="authors"><span class="speaker">Sobhan Chatterjee</span>, <span>Nathan Allen</span>, <span>Nitish Patel</span>, and <span>Partha S. Roop</span></div><div class="affiliations">(U. Auckland)</div><div class="abstract-text"><p>Neural networks have the ability to model complex input-output relationships without extensive information about system dynamics. Hence, data-driven approaches to Cyber-Physical Systems (CPS) using Neural Networks (NNs) have been gaining prominence. Such NNs are traditionally developed as large, monolithic black-box models, which are difficult to validate, especially for ensuring safety. Consequently, their implementation as a composition of smaller NNs, each performing individual tasks, has received considerable interest. These will be easier to validate, implement, parallelise and have the potential for incremental design. Despite this interest, the question of how implementations of Compositional NNs compare to Monolithic NNs quantitatively has received scant attention.</p>
<p>This work presents a comparative study on the implementation of both monolithic and compositional NN models on hardware using a new compiler that transforms Keras models . In the developed approach, we compile networks of Artificial Neural Networks to hardware implementations using new synchronous semantics for their execution. The developed semantics enables compilation of Compositional NNs to a parallel hardware implementation involving limited hardware resources whilst guaranteeing that the generated implementation is deterministic and time predictable. Overall, we show, through the complex example of  Discretionary Lane-Changing decision-making process of an Autonomous Vehicle,  the trade-offs involved in the hardware synthesis of a Compositional Model vis-a-vis a Monolithic Model. We illustrate that a compositional implementation on hardware can be particularly beneficial for systems with limited input-output capabilities at a marginal cost to functional performance.</p>
</div></div><div class="talk-details"><h2 id="Diagrammatic-semantics-for-digital-circuits">Diagrammatic semantics for digital circuits</h2><div class="when">27 November 2020, 10:30–11:00</div><div class="authors"><span><a href="https://www.cs.bham.ac.uk/~drg/?_ga=2.138870139.951683747.1605211235-2074045637.1605027542">Dan Ghica</a></span> and <span class="speaker"><a href="https://georgejkaye.com">George Kaye</a></span></div><div class="affiliations">(University of Birmingham)</div><div class="abstract-text"><p>Reasoning about software is usually performed using operational semantics, which is syntactic and reduction-based. Conversely, to reason about hardware it is usually translated into an automaton and its behaviour simulated.  Motivated by the advantages of the former, Ghica and Jung recently defined an operational semantics for digital circuits, where the behaviour of circuits is modelled by axioms in a symmetric traced monoidal category (STMC). However, reasoning syntactically over terms is not efficient - identifying redexes can be difficult. We therefore develop this work further by defining a graphical language for STMCs, using a variant on hypergraphs that we call 'linear hypergraphs'. This language is sound and complete - any morphism in the STMC can be interpreted as a well-formed linear hypergraph up to isomorphism, and any linear hypergraph is the representation of a unique morphism, up to the equational theory of the category. We can then express the axioms of digital circuits as graph rewrite rules - we show how we can use our graphical language to apply the framework of double pushout (DPO) rewriting to act as a graph rewriting diagrammatic semantics.</p>
</div></div><div class="talk-details"><h2 id="Modeling-and-design-of-neural-networks-architectures-for-neural-hybridation-based-on-synchronous-approaches">Modeling and design of neural networks architectures for neural hybridation based on synchronous approaches</h2><div class="when">27 November 2020, 11:00–11:30</div><div class="authors"><span class="speaker">Marino Rasamuel</span> and <span><a href="http://www.unice.fr/dgaffe/">Daniel Gaffe </a></span></div><div class="affiliations">(Univ. Côte d'Azur)</div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="A-reactive-semantics-for-a-higher-order-language-with-integer-clocks">A reactive semantics for a higher-order language with integer clocks</h2><div class="when">27 November 2020, 11:45–12:15</div><div class="authors"><span class="speaker">Ada Vienot</span></div><div class="affiliations">(IRIF - Université de Paris)</div><div class="abstract-text"><p>Many synchronous languages use reactive semantics - inputs arrive progressively, and outputs are produced progressively. Recently, other languages that are closer to lambda calculus have been inspired by guarded recursion - the doctrine of controlling causality to ensure well-definedness of recursive objects. These languages generally do not have reactive semantics, which jeopardizes their use in systems where efficiency is important. In this talk, we will give a reactive semantics for such a language - namely, Core Lambda*, introduced by Adrien Guatto. We will revisit well-known compilation techniques, like simple loop compilation (which is used in Lustre), and we will give a proof of correctness by using a logical relation.</p>
</div></div><div class="talk-details"><h2 id="Usuba--high-throughput-software-circuits-for-cryptography">Usuba, high-throughput software circuits for cryptography</h2><div class="when">27 November 2020, 14:15–14:45</div><div class="authors"><span class="speaker"><a href="https://pages.lip6.fr/Pierre-Evariste.Dagand/">Pierre-Évariste Dagand</a></span> and <span>Darius Mercadier </span></div><div class="affiliations">(Sorbonne University)</div><div class="material d-print-none"><a href="https://dadaiscrazy.github.io/usuba/">(material)</a></div><div class="abstract-text"><p>Cryptographic primitives are subject to diverging imperatives. Functional correctness and auditability pushes for the use of a high-level programming language. Performance and the threat of timing attacks push for using no more abstract than an assembler to exploit (or avoid!) the micro-architectural features of a given machine. We believe that a suitable programming language can reconcile both views and actually improve on the state of the art of both.</p>
<p>Usuba is an opinionated dataflow programming language in which block ciphers become so simple as to be “obviously correct” and whose types document valid parallelization strategies at the granularity of individual bits. Its optimizing compiler produces high-throughput, constant-time implementations performing on par with hand-tuned reference implementations. The cornerstone of our approach is a systematization and generalization of bitslicing, an implementation trick frequently used by cryptographers.</p>
</div></div><div class="talk-details"><h2 id="An-Overview-of-the-Synchronous-Language-Céu">An Overview of the Synchronous Language Céu</h2><div class="when">27 November 2020, 14:45–15:15</div><div class="authors"><span class="speaker"><a href="http://ceu-lang.org/chico/">Francisco Sant'anna</a></span></div><div class="affiliations">(Rio de Janeiro State University)</div><div class="material d-print-none"><a href="http://ceu-lang.org/">(material)</a></div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="A-Hard-Real-Time-Demonstrator-for-Dynamic-Ticks-and-Timed-SCCharts">A Hard Real Time Demonstrator for Dynamic Ticks and Timed SCCharts</h2><div class="when">27 November 2020, 15:30–16:00</div><div class="authors"><span class="speaker">Andreas Boysen</span>, <span><a href="https://www.rtsys.informatik.uni-kiel.de/en/team/alexander-schulz-rosengarten">Alexander Schulz-Rosengarten</a></span>, and <span><a href="https://www.rtsys.informatik.uni-kiel.de/en/team/rvh">Reinhard von Hanxleden</a></span></div><div class="affiliations">(University of Kiel)</div><div class="material d-print-none"><a href="https://rtsys.informatik.uni-kiel.de/~biblio/downloads/papers/fdl20-als.pdf">(material)</a></div><div class="abstract-text"><p>Synchronous programming languages, such as Esterel, Lustre, SCADE or SCCharts, have been developed for designing reactive systems. They abstract from computation times and assume that outputs are synchronous with their inputs. This leads to a deterministic semantics, without race conditions, which makes synchronous languages particularly suitable for safety-critical systems. However, even though synchronous languages have been designed with real-time applications in mind, the handling of physical time is traditionally left to the execution environment. This makes e.g. the expression of arbitrary time-outs difficult and may lead to excessive “busy waiting” computations. The recent proposal of dynamic ticks alleviates this by making physical time a first-class citizen within the synchronous programming model.</p>
<p>In this work, we explore and demonstrate the practical merits of dynamic ticks, including improved timing accuracy and reduced computational requirements, in the context of Timed SCCharts. As demonstration platform, we present a hardware/software platform that involves two stepper motors whose operation must be synchronized at microsecond accuracy to avoid physical damage.</p>
</div></div><div class="talk-details"><h2 id="Towards-verification-of-synchronous-hybrid-programs">Towards verification of synchronous hybrid programs</h2><div class="when">27 November 2020, 16:00–16:30</div><div class="authors"><span class="speaker"><a href="http://www-personal.umich.edu/~jeannin/">Jean-Baptiste Jeannin </a></span></div><div class="affiliations">(U. Michigan)</div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="On-the-efficiency-cost-of-common-isolation-properties-in-synchronous-and-real-time-systems-implementation">On the efficiency cost of common isolation properties in synchronous and real-time systems implementation</h2><div class="when">27 November 2020, 16:45–17:15</div><div class="authors"><span class="speaker"><a href="https://who.rocq.inria.fr/Dumitru.Potop_Butucaru/">Dumitru Potop-Butucaru</a></span></div><div class="affiliations">(Inria Paris)</div><div class="abstract-text"></div></div><div class="talk-details"><h2 id="Making-Mainstream-Programming-Languages-Deterministic-Again">Making Mainstream Programming Languages Deterministic Again</h2><div class="when">27 November 2020, 17:15–17:45</div><div class="authors"><span><a href="https://ptolemy.berkeley.edu/~eal/">Edward A. Lee</a></span>, <span><a href="https://personal.utdallas.edu/~soroush/">Soroush Bateni</a></span>, <span><a href="https://shaokai.co/">Shaokai Lin</a></span>, <span class="speaker"><a href="https://people.eecs.berkeley.edu/~marten/">Marten Lohstroh</a></span>, <span><a href="https://cfaed.tu-dresden.de/investigators-institutions/compiler-construction/ccc-staff/christian-menard">Christian Menard</a></span>, and <span><a href="https://www.rtsys.informatik.uni-kiel.de/en/team/alexander-schulz-rosengarten">Alexander Schulz-Rosengarten</a></span></div><div class="affiliations">(UC Berkeley, UT Dallas, TU Dresden, and University of Kiel)</div><div class="abstract-text"><p>Synchronous languages are unique in the programming world with their emphasis (with some exceptions) on deterministic concurrency. Determinism enhances testability, predictability, and verifiability, and yet, synchronous languages have largely not caught on in the general software engineering community. This talk is about a coordination language called Lingua Franca (LF) that is based in part on synchronous/reactive principles. It is a polyglot coordination language with support (so far) for C, C++, Python, and TypeScript (a statically typed version of JavaScript). Program logic is given in one or more of those target languages, enabling developers to use familiar languages and integrate extensive libraries and legacy code. Lingua Franca realizes a model of computation called Reactors (for actors, revisited) that extends synchronous/ reactive principles with a logical timeline and timestamped events. It supports asynchronous injection of events from the environment, using callbacks or interrupts for example, without compromising its deterministic semantics. It also includes support for real-time computing and deadlines, making it a suitable implementation language for cyber-physical systems. Moreover, the generated code (in the C and C++ targets) transparently executes in parallel on multicore machines. LF programs can be distributed across networks without losing their determinism, and the language includes explicitly nondeterministic constructs for applications that require and/or tolerate nondeterminism. Lingua Franca is an open-source, BSD-style licensed collaboration between UC Berkeley, UT Dallas, TU Dresden, and Kiel University.</p>
</div></div></div><div class="synchron-single-border"></div></div><script crossorigin="anonymous" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script><script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script><script src="js/bootstrap.min.js"></script></div></body></html>